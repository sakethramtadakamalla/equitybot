# -*- coding: utf-8 -*-
"""app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OJrZvU5OeaFy76QMR0pfRtAIOcPmjaH-
"""

import os
import requests
import pandas as pd
import numpy as np
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from datetime import datetime
from bs4 import BeautifulSoup
import yfinance as yf
from reportlab.pdfgen import canvas
from reportlab.lib.pagesizes import A4
from reportlab.lib.utils import ImageReader
from reportlab.lib.colors import black, blue, green, orange, red, white, gray, lightgrey
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, Image, PageBreak
from reportlab.lib.enums import TA_CENTER, TA_JUSTIFY
from reportlab.lib.units import inch
from io import BytesIO
from flask import Flask, render_template, request, jsonify, send_from_directory

# ------------------------
# Flask App Initialization
# ------------------------
app = Flask(__name__)
OUTPUT_FOLDER = 'outputs'
os.makedirs(OUTPUT_FOLDER, exist_ok=True)

# ------------------------
# DATA FOR THE FRONT-END & PEER ANALYSIS
# ------------------------
SECTOR_STOCK_MAPPING = {
    "Banking & Financials": [
        {"name": "HDFC Bank", "ticker": "HDFCBANK.NS"},
        {"name": "ICICI Bank", "ticker": "ICICIBANK.NS"},
        {"name": "State Bank of India", "ticker": "SBIN.NS"},
        {"name": "Kotak Mahindra Bank", "ticker": "KOTAKBANK.NS"},
        {"name": "Axis Bank", "ticker": "AXISBANK.NS"},
        {"name": "Bajaj Finance", "ticker": "BAJFINANCE.NS"},
    ],
    "IT": [
        {"name": "Infosys", "ticker": "INFY.NS"},
        {"name": "TCS", "ticker": "TCS.NS"},
        {"name": "Wipro", "ticker": "WIPRO.NS"},
        {"name": "Tech Mahindra", "ticker": "TECHM.NS"},
        {"name": "HCL Technologies", "ticker": "HCLTECH.NS"},
    ],
    "Energy": [
        {"name": "Reliance Industries", "ticker": "RELIANCE.NS"},
        {"name": "ONGC", "ticker": "ONGC.NS"},
        {"name": "NTPC", "ticker": "NTPC.NS"},
        {"name": "Power Grid", "ticker": "POWERGRID.NS"},
        {"name": "Adani Power", "ticker": "ADANIPOWER.NS"},
        {"name": "Tata Power", "ticker": "TATAPOWER.NS"},
    ],
    "Automobiles": [
        {"name": "Tata Motors", "ticker": "TATAMOTORS.NS"},
        {"name": "Mahindra and Mahindra", "ticker": "M&M.NS"},
        {"name": "Maruti Suzuki", "ticker": "MARUTI.NS"},
        {"name": "Eicher Motors", "ticker": "EICHERMOT.NS"},
        {"name": "Bajaj Auto", "ticker": "BAJAJ-AUTO.NS"},
    ],
}

PEER_MAPPING = {
    "HDFCBANK.NS": ["ICICIBANK.NS", "SBIN.NS", "AXISBANK.NS", "KOTAKBANK.NS"],
    "ICICIBANK.NS": ["HDFCBANK.NS", "AXISBANK.NS", "KOTAKBANK.NS", "SBIN.NS"],
    "SBIN.NS": ["HDFCBANK.NS", "ICICIBANK.NS", "PNB.NS", "BANKBARODA.NS"],
    "INFY.NS": ["TCS.NS", "WIPRO.NS", "TECHM.NS", "HCLTECH.NS"],
    "TCS.NS": ["INFY.NS", "WIPRO.NS", "HCLTECH.NS", "TECHM.NS"],
    "RELIANCE.NS": ["ONGC.NS", "TATAPOWER.NS", "ADANIPOWER.NS"],
    "TATAMOTORS.NS": ["MARUTI.NS", "M&M.NS", "EICHERMOT.NS"],
}


# ======================================================================
# DATA FETCHING AND ANALYSIS FUNCTIONS (CORRECTED)
# ======================================================================

def get_scalar(value):
    """Helper function to ensure a value is a single number, not a pandas Series."""
    if isinstance(value, pd.Series):
        return value.iloc[0] if not value.empty else None
    return value

def fetch_price(symbol, period="3y"):
    df = yf.download(symbol, period=period, interval="1d", progress=False, auto_adjust=True)
    return df if not df.empty else None

def compute_technical_indicators(df):
    if df is None: return None
    df['sma_50'] = df['Close'].rolling(window=50).mean()
    df['sma_200'] = df['Close'].rolling(window=200).mean()
    df['bb_mid'] = df['Close'].rolling(window=20).mean()
    df['bb_std'] = df['Close'].rolling(window=20).std()
    df['bb_upper'] = df['bb_mid'] + 2 * df['bb_std']
    df['bb_lower'] = df['bb_mid'] - 2 * df['bb_std']
    df['ema_12'] = df['Close'].ewm(span=12, adjust=False).mean()
    df['ema_26'] = df['Close'].ewm(span=26, adjust=False).mean()
    df['macd_line'] = df['ema_12'] - df['ema_26']
    df['macd_signal'] = df['macd_line'].ewm(span=9, adjust=False).mean()
    df['macd_hist'] = df['macd_line'] - df['macd_signal']
    delta = df['Close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
    rs = gain / loss.replace(0, 1e-9)
    df['rsi'] = 100 - (100 / (1 + rs))
    return df

def fetch_company_info(symbol):
    try:
        ticker = yf.Ticker(symbol)
        info = ticker.info
        unit_divisor = 1e7
        return {
            'Symbol': symbol, 'Company Name': info.get('longName', 'N/A'),
            'Description': info.get('longBusinessSummary', 'N/A'),
            'Market Cap': f"₹{info.get('marketCap', 0) / unit_divisor:,.2f} Cr",
            'Current Price': f"₹{info.get('currentPrice', 'N/A')}",
            'Trailing PE': info.get('trailingPE'), 'Forward PE': info.get('forwardPE'),
            'Price/Book': info.get('priceToBook'),
            'ROE': info.get('returnOnEquity'),
            'Profit Margin': info.get('profitMargins'),
            'Debt to Equity': info.get('debtToEquity'),
            'Current Ratio': info.get('currentRatio'),
        }
    except Exception as e:
        print(f"Error fetching fundamental data for {symbol}: {e}")
        return None

def fetch_news_yfinance(symbol, limit=8):
    news = []
    try:
        ticker = yf.Ticker(symbol)
        news_data = ticker.news
        for item in news_data[:limit]:
            news.append({'title': item.get('title', 'N/A'), 'publisher': item.get('publisher', 'N/A')})
    except Exception as e:
        print(f"Error fetching news from yfinance: {e}")
    return news

def get_peer_comparison(peers):
    peer_details = []
    for peer_symbol in peers:
        try:
            info = yf.Ticker(peer_symbol).info
            peer_details.append({
                'name': info.get('shortName', peer_symbol),
                'pe': info.get('trailingPE'),
                'roe': info.get('returnOnEquity')
            })
        except Exception:
            continue
    return pd.DataFrame(peer_details)

def interpret_technical(df):
    analysis = []
    latest = df.iloc[-1]

    # Use the get_scalar helper function to ensure we compare single numbers
    sma_50 = get_scalar(latest['sma_50'])
    sma_200 = get_scalar(latest['sma_200'])
    bb_upper = get_scalar(latest['bb_upper'])
    bb_lower = get_scalar(latest['bb_lower'])
    close_price = get_scalar(latest['Close'])
    macd_line = get_scalar(latest['macd_line'])
    macd_signal = get_scalar(latest['macd_signal'])
    rsi = get_scalar(latest['rsi'])

    if sma_50 is not None and sma_200 is not None:
        if sma_50 > sma_200:
            analysis.append("<b>Trend:</b> Bullish Signal (Golden Cross). The short-term 50-day average is above the long-term 200-day average, indicating positive upward momentum.")
        else:
            analysis.append("<b>Trend:</b> Bearish Signal (Death Cross). The 50-day average has crossed below the 200-day average, a negative long-term signal.")
    if bb_upper is not None and close_price > bb_upper:
        analysis.append("<b>Volatility:</b> High. The price is trading above the upper Bollinger Band, which can signal an overbought condition.")
    elif bb_lower is not None and close_price < bb_lower:
        analysis.append("<b>Volatility:</b> High. The price is below the lower Bollinger Band, suggesting a potential oversold condition.")
    if macd_line is not None and macd_signal is not None:
        if macd_line > macd_signal:
            analysis.append("<b>Momentum (MACD):</b> Positive. The MACD line is above its signal line, indicating bullish momentum in the short term.")
        else:
            analysis.append("<b>Momentum (MACD):</b> Negative. The MACD line is below its signal line, indicating bearish momentum.")
    if rsi is not None:
        if rsi > 70:
            analysis.append(f"<b>Strength (RSI):</b> Overbought. The RSI is high at {rsi:.2f}, suggesting the asset may be overvalued and could be due for a pullback.")
        elif rsi < 30:
            analysis.append(f"<b>Strength (RSI):</b> Oversold. The RSI is low at {rsi:.2f}, suggesting the asset may be undervalued and poised for a rebound.")
        else:
            analysis.append(f"<b>Strength (RSI):</b> Neutral. The RSI is balanced at {rsi:.2f}, indicating no immediate overbought or oversold pressure.")

    if not analysis:
        analysis.append("Could not generate a detailed technical analysis due to insufficient data.")

    return analysis

def interpret_fundamental(fundamentals):
    analysis = []
    if fundamentals.get('Trailing PE'):
        pe = fundamentals['Trailing PE']
        valuation = "potentially overvalued (high P/E)" if pe > 30 else "potentially undervalued (low P/E)" if pe < 15 else "fairly valued"
        analysis.append(f"<b>Valuation:</b> With a P/E Ratio of {pe:.2f}, the stock appears {valuation} compared to traditional benchmarks.")
    if fundamentals.get('ROE'):
        roe = fundamentals['ROE']
        quality = "strong" if roe > 0.15 else "moderate"
        analysis.append(f"<b>Profitability:</b> A Return on Equity of {roe*100:.2f}% indicates {quality} efficiency in generating profit from shareholder equity.")
    if fundamentals.get('Debt to Equity'):
        de = fundamentals['Debt to Equity']
        risk = "high, suggesting increased risk" if de > 150 else "manageable"
        analysis.append(f"<b>Financial Health:</b> The Debt to Equity ratio of {de:.2f} is {risk}.")
    return analysis

def generate_recommendation(fundamentals, tech_analysis):
    score = 0
    if fundamentals.get('ROE') and fundamentals['ROE'] > 0.15: score += 1
    if fundamentals.get('Trailing PE') and fundamentals['Trailing PE'] < 30: score += 1
    if fundamentals.get('Debt to Equity') and fundamentals['Debt to Equity'] < 150: score += 1
    if any("Bullish" in s for s in tech_analysis): score += 1
    if any("Overbought" in s for s in tech_analysis): score -= 1
    if score >= 3: return "BUY"
    if score >= 1: return "HOLD"
    return "SELL"

# --- (The generate_pdf_report function remains the same as the previous version) ---
def generate_pdf_report(fundamentals, price_df, news, peer_df, tech_analysis, fund_analysis, recommendation):
    stock_name = fundamentals.get('Symbol', 'STOCK')
    filename = f"{stock_name.replace('.', '_')}_Full_Report_{datetime.now().strftime('%Y%m%d')}.pdf"
    filepath = os.path.join(OUTPUT_FOLDER, filename)
    doc = SimpleDocTemplate(filepath, pagesize=A4, rightMargin=inch*0.5, leftMargin=inch*0.5, topMargin=inch*0.5, bottomMargin=inch*0.5)
    story = []
    styles = getSampleStyleSheet()

    story.append(Paragraph(f"Saketh Equity Research Report: {fundamentals.get('Company Name', '')}", styles['h1']))
    story.append(Paragraph(f"Date: {datetime.now().strftime('%d %B %Y')}", styles['h2']))
    story.append(Spacer(1, 12))

    rec_color = {'BUY': green, 'HOLD': orange, 'SELL': red}.get(recommendation, black)
    header_data = [[Paragraph(f"<b>Current Price:</b> {fundamentals.get('Current Price', 'N/A')}<br/><b>Market Cap:</b> {fundamentals.get('Market Cap', 'N/A')}", styles['Normal']), Paragraph(f"<font size=24 color='{rec_color.hexval()}'>{recommendation}</font>", styles['h1'])]]
    story.append(Table(header_data, colWidths=[4*inch, 2.5*inch], style=[('VALIGN', (0,0), (-1,-1), 'MIDDLE'), ('ALIGN', (1,0), (1,0), 'RIGHT')]))
    story.append(Spacer(1, 12))

    story.append(Paragraph("Company Overview", styles['h3']))
    story.append(Paragraph(fundamentals.get('Description', 'N/A'), styles['Justify']))
    story.append(Spacer(1, 12))

    analysis_data = [
        [Paragraph("<b>Technical Analysis Summary</b>", styles['h4']), Paragraph("<b>Fundamental Analysis Summary</b>", styles['h4'])],
        [Paragraph("<br/>".join([f"• {item}" for item in tech_analysis]), styles['Normal']), Paragraph("<br/>".join([f"• {item}" for item in fund_analysis]), styles['Normal'])]
    ]
    story.append(Table(analysis_data, colWidths=[3.5*inch, 3.5*inch], style=[('GRID', (0,0), (-1,-1), 1, black), ('VALIGN', (0,0), (-1,-1), 'TOP'), ('LEFTPADDING', (0,0), (-1,-1), 6)]))
    story.append(PageBreak())

    story.append(Paragraph("Technical Charts (3-Year)", styles['h3']))
    try:
        fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(8, 9), gridspec_kw={'height_ratios': [3, 1, 1]})
        fig.suptitle(f'Technical Analysis for {stock_name}', fontsize=16)

        ax1.plot(price_df.index, price_df['Close'], label='Close Price', color='blue', linewidth=1.5)
        ax1.plot(price_df.index, price_df['sma_50'], label='50-Day SMA', color='orange', linestyle='--', alpha=0.8)
        ax1.plot(price_df.index, price_df['sma_200'], label='200-Day SMA', color='red', linestyle='--', alpha=0.8)
        ax1.plot(price_df.index, price_df['bb_upper'], label='Bollinger Upper', color='gray', linestyle=':', alpha=0.6)
        ax1.plot(price_df.index, price_df['bb_lower'], label='Bollinger Lower', color='gray', linestyle=':', alpha=0.6)
        ax1.fill_between(price_df.index, price_df['bb_upper'], price_df['bb_lower'], color='gray', alpha=0.1)
        ax1.set_ylabel('Price (₹)', fontsize=9)
        ax1.legend()
        ax1.grid(True, linestyle='--', alpha=0.6)

        ax2.plot(price_df.index, price_df['macd_line'], label='MACD Line', color='green')
        ax2.plot(price_df.index, price_df['macd_signal'], label='Signal Line', color='red', linestyle='--')
        ax2.bar(price_df.index, price_df['macd_hist'], label='Histogram', color='gray', alpha=0.5)
        ax2.set_ylabel('MACD', fontsize=9)
        ax2.legend()
        ax2.grid(True, linestyle='--', alpha=0.6)

        ax3.plot(price_df.index, price_df['rsi'], label='RSI', color='purple')
        ax3.axhline(70, linestyle='--', color='red', alpha=0.7); ax3.axhline(30, linestyle='--', color='green', alpha=0.7)
        ax3.set_ylabel('RSI', fontsize=9)
        ax3.legend()
        ax3.grid(True, linestyle='--', alpha=0.6)

        for ax in [ax1, ax2, ax3]:
            ax.tick_params(axis='x', labelsize=8, rotation=30, ha='right')
            ax.tick_params(axis='y', labelsize=8)

        plt.tight_layout(rect=[0, 0, 1, 0.96])
        img_buffer = BytesIO()
        fig.savefig(img_buffer, format='png', dpi=300); plt.close(fig)
        story.append(Image(img_buffer, width=7*inch, height=7.5*inch))
    except Exception as e:
        story.append(Paragraph(f"Could not generate charts: {e}", styles['Normal']))
    story.append(Spacer(1, 12))

    story.append(Paragraph("Key Financial Ratios", styles['h3']))
    ratios_data = [['Trailing P/E', f"{fundamentals.get('Trailing PE'):.2f}" if fundamentals.get('Trailing PE') else 'N/A'], ['Forward P/E', f"{fundamentals.get('Forward PE'):.2f}" if fundamentals.get('Forward PE') else 'N/A'], ['Price/Book (P/B)', f"{fundamentals.get('Price/Book'):.2f}" if fundamentals.get('Price/Book') else 'N/A'], ['Return on Equity (ROE)', f"{fundamentals.get('ROE')*100:.2f}%" if fundamentals.get('ROE') else 'N/A'], ['Profit Margin', f"{fundamentals.get('Profit Margin')*100:.2f}%" if fundamentals.get('Profit Margin') else 'N/A'], ['Debt to Equity', f"{fundamentals.get('Debt to Equity'):.2f}" if fundamentals.get('Debt to Equity') else 'N/A'], ['Current Ratio', f"{fundamentals.get('Current Ratio'):.2f}" if fundamentals.get('Current Ratio') else 'N/A']]
    story.append(Table(ratios_data, style=[('GRID', (0,0), (-1,-1), 1, black), ('FONTNAME', (0,0), (0,-1), 'Helvetica-Bold')]))
    story.append(Spacer(1, 12))

    story.append(Paragraph("Peer Comparison", styles['h3']))
    if not peer_df.empty:
        peer_data = [['Company', 'P/E Ratio', 'Return on Equity (ROE)']]
        for index, row in peer_df.iterrows():
            peer_data.append([row['name'], f"{row['pe']:.2f}" if pd.notna(row['pe']) else 'N/A', f"{row['roe']*100:.2f}%" if pd.notna(row['roe']) else 'N/A'])
        story.append(Table(peer_data, style=[('GRID', (0,0), (-1,-1), 1, black), ('BACKGROUND', (0,0), (-1,0), lightgrey), ('FONTNAME', (0,0), (-1,0), 'Helvetica-Bold')]))
    else:
        story.append(Paragraph("No peer data available.", styles['Normal']))
    story.append(Spacer(1, 12))

    story.append(Paragraph("Recent News", styles['h3']))
    for n in news:
        story.append(Paragraph(f"• <b>{n['title']}</b> <i>({n['publisher']})</i>", styles['Normal']))

    doc.build(story)
    return filename

# ======================================================================
# FLASK WEB ROUTES (The part that makes it a website)
# ======================================================================

def create_report(stock_ticker):
    symbol = stock_ticker
    fundamentals = fetch_company_info(symbol)
    if not fundamentals: raise ValueError(f"Could not get data for {symbol}.")
    price_df = fetch_price(symbol)
    if price_df is None: raise ValueError(f"Could not get price history for {symbol}.")

    price_df_tech = compute_technical_indicators(price_df)
    tech_analysis = interpret_technical(price_df_tech)
    fund_analysis = interpret_fundamental(fundamentals)
    recommendation = generate_recommendation(fundamentals, tech_analysis)

    peers = PEER_MAPPING.get(symbol, [])
    peer_df = get_peer_comparison(peers)
    news = fetch_news_yfinance(symbol)

    pdf_filename = generate_pdf_report(fundamentals, price_df, news, peer_df, tech_analysis, fund_analysis, recommendation)
    return pdf_filename

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/api/stocks')
def get_stocks():
    return jsonify(SECTOR_STOCK_MAPPING)

@app.route('/generate', methods=['POST'])
def generate():
    try:
        stock_ticker = request.form['stock_select']
        if not stock_ticker: return jsonify({'error': 'No stock selected.'}), 400
        pdf_filename = create_report(stock_ticker)
        return jsonify({'download_url': f"/download/{pdf_filename}"})
    except ValueError as e:
        return jsonify({'error': str(e)}), 400
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        return jsonify({'error': 'An internal server error occurred. Please try again later.'}), 500

@app.route('/download/<filename>')
def download_file(filename):
    return send_from_directory(OUTPUT_FOLDER, filename, as_attachment=True)

if __name__ == "__main__":
    app.run(debug=True)